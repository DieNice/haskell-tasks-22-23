# Индивидуальные задания

Единственное требование в этом случае: студент должен объяснить преподавателю структуру программы на ПРОЛОГ для данной программной реализации, а также особенности данной реализации.

**Вариант 1.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Добавление элемента в список
2.Проверка на принадлежность элемента
3.Вычисление длины списка
4.Вычисление минимального элемента списка
5.Вычисление максимального элемента списка
6.Сортировка элементов списка
7.Вычисление суммы элементов списка

**Вариант 2.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление разности соседних элементов списка
2.Проверка на принадлежность элемента списку разностей
3.Вычисление длины списка разностей
4.Вычисление минимальной разности
5.Вычисление произведений соседних элементов списка
6.Сортировка элементов списка произведений по убыванию
7.Сортировка элементов списка разностей по возрастанию

**Вариант 3.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Конкатенация двух списков
2.Инверсия списка
3.Вывод на экран элементов списка
4.Подсчет числа вхождений в список некоторого элемента.
5.Проверка, является ли один список подсписком другого списка.
6.Выделение подсписка 
7.Удаление повторяющихся элементов списка с сохранением порядка.

**Вариант 4**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Добавление элемента.
2.Удаление элемента.
3.Проверка на принадлежность.
4.Объединение.
5.Пересечение.
6.Разность.  
7.Вывод на экран элементов множества в порядке возрастания
Примечание.
Множества представлять в виде списков.

**Вариант 5.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Проверка включения множества в другое.
2.Проверка равенства двух множеств.
3.Подсчет числа элементов множества.
4.Вывод на экран элементов множества.
5.Поиск минимального элемента множества
6.Поиск максимального элемента множества 
7.Разбиение множества на классы эквивалентности (при условии что задано отношение эквивалентности двух элементов множества p(x,y)).
Примечание.
Множества представлять в виде списков.

**Вариант 6.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Проверка включения множества в другое.
2.Проверка равенства двух множеств.
3.Подсчет числа элементов множества.
4.Вывод на экран элементов множества.
5.Поиск минимального элемента множества
6.Поиск максимального элемента множества 
7.Разбиение множества на классы эквивалентности (при условии что задано отношение эквивалентности двух элементов множества p(x,y)).

**Вариант 7.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Добавление элемента.
2.Удаление элемента.
3.Проверка на принадлежность.
4.Объединение.
5.Пересечение.
6.Разность.  
7.Вывод на экран элементов множества в порядке возрастания
Примечание.
Для представления множеств использовать двоичные деревья. 

**Вариант 8.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность выполнения самого себя.
1.Проверка включения множества в другое.
2.Проверка равенства двух множеств.
3.Подсчет числа элементов множества.
4.Вывод на экран элементов множества.
5.Поиск минимального элемента множества
6.Поиск максимального элемента множества 
7.Разбиение множества на классы эквивалентности (при условии что задано отношение эквивалентности двух элементов множества p(x,y)).
Примечание.
Для представления множеств использовать двоичные деревья. 

**Вариант 9**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Перестановка четных и нечетных элементов списка
2.Проверка на не принадлежность элемента списку
3.Сформировать из исходного списка такой, в котором не содержатся элементы, входящие в первый список более, чем один раз
4.Вычисление длины нового списка
5.Вычисление минимального элемента нового списка
6.Вычисление сумм элементов исходного и нового списка
7.Вычисление максимального элемента из двух сумм

**Вариант 10.**
Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление разности соседних четных элементов списка
2.Проверка на принадлежность каждого элемента списка разностей исходному списку
3.Вычисление длины списка разностей
4.Вычисление минимальной разности
5.Вычисление произведений соседних элементов списка
6.Сортировка элементов списка произведений по убыванию
7.Сортировка элементов списка разностей по возрастанию

**Вариант 11.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Конкатенация двух упорядоченных по возрастанию списков так, чтобы полученный список также был упорядочен по возрастанию
2.Инверсия списка
3.Вывод на экран элементов списка
4.Сформировать для заданного списка список, элементами которого являются числа, задающие число вхождений каждого элемента исходного списка в этот список.
5.Проверка, является ли один список подсписком другого списка, причем таким, что все его элементы являются последними элементами исходного списка. Например, для двух списков [a,d,c,b,d,f,a] и [d,f,a] результат yes.
6.Выделение подсписка, первым элементом которого будет заданный элемент
7.Удаление повторяющихся элементов списка с сохранением порядка.

**Вариант 12**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Перестановка четных и нечетных элементов списка
2.Проверка на не принадлежность элемента списку
3.Сформировать из исходного списка такой, в котором не содержатся элементы, входящие в первый список более, чем один раз
4.Вычисление длины нового списка
5.Вычисление минимального элемента нового списка
6.Вычисление сумм элементов исходного и нового списка
7.Вычисление максимального элемента из двух сумм
Для представления списков использовать двоичные деревья

**Вариант 13.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление разности соседних четных элементов списка
2.Проверка на принадлежность каждого элемента списка разностей исходному списку
3.Вычисление длины списка разностей
4.Вычисление минимальной разности
5.Вычисление произведений соседних элементов списка
6.Сортировка элементов списка произведений по убыванию
7.Сортировка элементов списка разностей по возрастанию
Для представления списков использовать двоичные деревья

**Вариант 14.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Конкатенация двух упорядоченных по возрастанию списков так, чтобы полученный список также был упорядочен по возрастанию
2.Инверсия списка
3.Вывод на экран элементов списка
4.Сформировать для заданного списка список, элементами которого являются числа, задающие число вхождений каждого элемента исходного списка в этот список.
5.Проверка, является ли один список подсписком другого списка, причем таким, что все его элементы являются последними элементами исходного списка. Например, для двух списков [a,d,c,b,d,f,a] и [d,f,a] результат yes.
6.Выделение подсписка, первым элементом которого будет заданный элемент
7.Удаление повторяющихся элементов списка с сохранением порядка.
Для представления списков использовать двоичные деревья

**Вариант 15**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Добавление заданных элементов.
2.Удаление заданных элементов.
3.Проверка на принадлежность.
4.Объединение трех множеств.
5.Пересечение трех множеств.
6.Вывод на экран элементов множества в порядке возрастания
Примечание. Множества представлять в виде списков.

**Вариант 16.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Для заданных трех множеств проверить, что первое является подмножеством второго, а второе – подмножеством третьего.
2.Проверка равенства двух множеств.
3.Подсчет числа положительных элементов множества.
4.Вывод на экран отрицательных элементов множества.
5.Поиск минимального положительного элемента множества
6.Поиск максимального отрицательного элемента множества 
Примечание.
Множества представлять в виде списков.

**Вариант 17.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Для произвольных двух множеств проверить, что все положительные элементы первого множества содержатся во втором.
2.Для двух заданных множеств проверить, что все отрицательные элементы первого не содержатся во втором.
3.Подсчет числа элементов множества, больших всех элементов второго множества.
4.Вывод на экран элементов множества.
5.Поиск максимального среди тех элементов множества, которые больше заданного числа 
Примечание.
Множества представлять в виде списков.

**Вариант 18.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Для заданных трех множеств проверить, что первое является подмножеством второго, а второе – подмножеством третьего.
2.Проверка равенства двух множеств.
3.Подсчет числа положительных элементов множества.
4.Вывод на экран отрицательных элементов множества.
5.Поиск минимального положительного элемента множества
6.Поиск максимального отрицательного элемента множества 
Примечание.
Для представления множеств использовать двоичные деревья. 


**Вариант 19.**

Реализовать на Прологе набор предикатов работы с множествами.
Каждый предикат должен вычислять сложность выполнения самого себя.
1.Для произвольных двух множеств проверить, что все положительные элементы первого множества содержатся во втором.
2.Для двух заданных множеств  проверить, что все отрицательные элементы первого не содержатся во втором.
3.Подсчет числа элементов множества, больших всех элементов второго множества.
4.Вывод на экран элементов множества.
5.Поиск максимального среди тех элементов множества, которые больше заданного числа 
Примечание.
Для представления множеств использовать двоичные деревья. 

**Вариант 20.**

Реализовать на Прологе предикаты работы с множествами
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Для двух заданных множеств проверить, что каждый третий элемент первого множества принадлежит второму, а каждый второй элемент второго множества не принадлежит первому
2.Добавить ко второму множеству те четные элементы первого множества, которые больше заданного числа
3.Вычисление числа элементов полученного второго множества
4.Вычисление минимального элемента среди тех элементов первого множества, которые меньше заданного числа 
5.Вычисление максимального элемента среди тех элементов второго множества, которые меньше максимального элемента первого множества
6.Вычисление суммы тех элементов, которые больше заданного числа 
Множество представляется списком

**Вариант 21.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление разности четных элементов списка
2.Исключить из списка все положительные элементы
3.Вычисление длины полученного списка
4.Вычисление минимального среди тех элементов полученного списка, которые больше заданного числа 
5.Вычисление произведений нечетных элементов списка
6.Сортировка элементов списка произведений по убыванию

**Вариант 22.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Конкатенация двух упорядоченных по убыванию списков так, чтобы результирующий список также был упорядочен по убыванию
2.Из исходного списка сформировать список, в котором нечетный и четный элементы поменялись местами
3.Вывод на экран элементов списка
4.Для заданного списка сформировать список, который содержит те элементы исходного списка, число вхождений которых в исходный список превышает заданного числа.
5.Проверка, является ли один список подсписком другого списка.
6.Выделение подсписка, начинающегося заданным элементом и заканчивающимся другим заданным элементом 

**Вариант 23.**

Реализовать на Прологе предикаты работы с множествами
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Для двух заданных множеств проверить, что каждый третий элемент первого множества принадлежит второму, а каждый второй элемент второго множества не принадлежит первому
2.Добавить ко второму множеству те четные элементы первого множества, которые больше заданного числа
3.Вычисление числа элементов полученного второго множества
4.Вычисление минимального элемента среди тех элементов первого множества, которые меньше заданного числа 
5.Вычисление максимального элемента среди тех элементов второго множества, которые меньше максимального элемента первого множества
6.Вычисление суммы тех элементов, которые больше заданного числа 
Множество представляется бинарным деревом

**Вариант 24.**

Используя представление списков в виде бинарного дерева, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление разности четных элементов списка
2.Исключить из списка все положительные элементы
3.Вычисление длины полученного списка
4.Вычисление минимального среди тех элементов полученного списка, которые больше заданного числа 
5.Вычисление произведений нечетных элементов списка
6.Сортировка элементов списка произведений по убыванию

**Вариант 25.**

Используя представление списков в виде бинарного дерева, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Конкатенация двух упорядоченных по убыванию списков так, чтобы результирующий список также был упорядочен по убыванию
2.Из исходного списка сформировать список, в котором нечетный и четный элементы поменялись местами
3.Вывод на экран элементов списка
4.Для заданного списка сформировать список, который содержит те элементы исходного списка, число вхождений которых в исходный список превышает заданного числа.
5.Проверка, является ли один список подсписком другого списка.
6.Выделение подсписка, начинающегося заданным элементом и заканчивающимся другим заданным элементом 

**Вариант 26.**

Реализовать на Прологе предикаты работы с множествами
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Для двух заданных множеств проверить, что каждый нечетный элемент первого множества принадлежит второму, а каждый четный элемент второго множества не принадлежит первому
2.Добавить к первому множеству те нечетные элементы второго множества, которые больше заданного числа
3.Вычисление числа элементов полученного первого множества
4.Вычисление минимального элемента среди тех элементов первого множества, которые положительные и меньше заданного числа 
5.Вычисление максимального элемента среди тех элементов второго множества, которые отрицательные и меньше максимального элемента первого множества
6.Вычисление суммы тех отрицательных элементов, которые больше заданного числа 
Для представления множеств использовать списки

**Вариант 27.**

Реализовать на Прологе предикаты работы с множествами
Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя. 
1.Для двух заданных множеств проверить, что каждый нечетный элемент первого множества принадлежит второму, а каждый четный элемент второго множества не принадлежит первому
2.Добавить к первому множеству те нечетные элементы второго множества, которые больше заданного числа
3.Вычисление числа элементов полученного первого множества
4.Вычисление минимального элемента среди тех элементов первого множества, которые положительные и меньше заданного числа 
5.Вычисление максимального элемента среди тех элементов второго множества, которые отрицательные и меньше максимального элемента первого множества
6.Вычисление суммы тех отрицательных элементов, которые больше заданного числа 
Для представления множеств использовать бинарные деревья

**Вариант 28.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление суммы нечетных элементов списка
2.Исключить из списка все отрицательные элементы, большие заданного числа
3.Вычисление длины полученного списка
4.Вычисление максимального среди тех элементов полученного списка, которые меньше заданного числа 
5.Вычисление произведений четных элементов списка, больших заданного числа
6.Сортировка элементов списка произведений по возрастанию

**Вариант 29.**

Используя стандартное представление для списков, запрограммировать на Прологе следующие предикаты работы со списками. Каждый предикат должен вычислять сложность (число шагов, необходимых для вычисления) для самого себя.
1.Вычисление суммы нечетных элементов списка
2.Исключить из списка все отрицательные элементы, большие заданного числа
3.Вычисление длины полученного списка
4.Вычисление максимального среди тех элементов полученного списка, которые меньше заданного числа 
5.Вычисление произведений четных элементов списка, больших заданного числа
6.Сортировка элементов списка произведений по возрастанию
