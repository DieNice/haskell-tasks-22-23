-- Задание:
-- Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна
-- - количество вызовов функции растет экспоненциально с ростом значения аргумента. GНСi позволяет отслеживать
-- использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду : зет +з :
-- GHCt> :set +s
-- GHCt> fibonacci 30
-- 832040
-- (8.36 secs, 298293400 bytes)
-- С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

fibonacci :: Integer -> Integer
fibonacci n = fib n 0 1
  where
    fib 0 a _ = a
    fib n a b = fib (n - 1) b (a + b)

fibonacci_bad :: Integer -> Integer
fibonacci_bad n
    | n == 0 = 0
    | n == 1 = 1
    | n > 0 = fibonacci_bad (n - 1) + fibonacci_bad (n - 2)

-- Prelude> :load task_3.hs
-- [1 of 1] Compiling Main             ( task_3.hs, interpreted )
-- Ok, one module loaded.
-- *Main> :set +s
-- *Main> fibonacci 30
-- 832040
-- (0.01 secs, 73,296 bytes)
-- *Main> fibonacci_bad 30
-- 832040
-- (2.45 secs, 781,569,248 bytes)
