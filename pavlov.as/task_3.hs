-- Задание:
-- Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении, крайне неэффективна
-- - количество вызовов функции растет экспоненциально с ростом значения аргумента. GНСi позволяет отслеживать
-- использование памяти и затраты времени на вычисление выражения, для этого следует выполнить команду : зет +з :
-- GHCt> :set +s
-- GHCt> fibonacci 30
-- 832040
-- (8.36 secs, 298293400 bytes)
-- С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию, имеющую линейную сложность (по числу рекурсивных вызовов). Как и в предыдущем задании, функция должна быть определена для всех целых чисел.

fibonacci :: Integer -> Integer
fibonacci n = fib n 0 1
  where
    fib 0 a _ = a
    fib n a b = fib (n - 1) b (a + b)

fibonacci_bad :: Integer -> Integer
fibonacci_bad n
    | n == 0 = 0
    | n == 1 = 1
    | n > 0 = fibonacci_bad (n - 1) + fibonacci_bad (n - 2)
